# SPDX-FileCopyrightText: 2025 Rayleigh Research <to@rayleigh.re>
# SPDX-License-Identifier: MIT
from taos.common.protocol import BaseModel
from pydantic import Field
from taos.im.protocol.simulator import *
from taos.common.protocol import SimulationEvent
from taos.im.utils import duration_from_timestamp
from taos.im.protocol.models import LoanSettlementOption, OrderCurrency

"""
Classes representing events occurring in the simulation are defined here.
"""

def abbreviate(type_name : str):
    return ''.join([s[0] for s in type_name.split('_')])
class FinanceEvent(SimulationEvent):
    """
    Base class for representing market events occurring in the simulation.
    """            
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform agent event messages generated by simulator to the format required by the MarketSimulationStateUpdate synapse.
        """
        match json['type']:
            case "EVENT_SIMULATION_START":
                return SimulationStartEvent.from_json(json)
            case "RESPONSE_DISTRIBUTED_PLACE_ORDER_LIMIT" | "ERROR_RESPONSE_DISTRIBUTED_PLACE_ORDER_LIMIT":
                return LimitOrderPlacementEvent.from_json(json)
            case "RESPONSE_DISTRIBUTED_PLACE_ORDER_MARKET" | "ERROR_RESPONSE_DISTRIBUTED_PLACE_ORDER_MARKET":
                return MarketOrderPlacementEvent.from_json(json)
            case "EVENT_TRADE":
                return TradeEvent.from_json(json)
            case "RESPONSE_DISTRIBUTED_CANCEL_ORDERS" | "ERROR_RESPONSE_DISTRIBUTED_CANCEL_ORDERS":
                return OrderCancellationsEvent.from_json(json)
            case "RESPONSE_DISTRIBUTED_CLOSE_POSITIONS" | "ERROR_RESPONSE_DISTRIBUTED_CLOSE_POSITIONS":
                return ClosePositionsEvent.from_json(json)
            case "RESPONSE_DISTRIBUTED_RESET_AGENT" | "ERROR_RESPONSE_DISTRIBUTED_RESET_AGENT":
                return ResetAgentsEvent.from_json(json)
            case "EVENT_SIMULATION_END":
                return SimulationEndEvent.from_json(json)

class SimulationStartEvent(FinanceEvent):
    """
    Represents the event generated on simulation start.

    Attributes:
        logDir (str): The directory where simulation outputs are recorded by the simulator.
    """
    l : str = Field(alias="logDir")
    
    @property
    def logDir(self) -> str:
        return self.l
    
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        return SimulationStartEvent.model_construct(
            type=abbreviate(json['type']), timestamp=json['timestamp'], agentId=None, logDir=json['payload']['logDir']
        )
        
    def __str__(self):
        return f"SIMULATION STARTED!"

class SimulationEndEvent(FinanceEvent):
    """
    Represents the event generated on simulation end.
    """
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        return SimulationEndEvent.model_construct(
            type=abbreviate(json['type']), timestamp=json['timestamp'], agentId=None
        )
        
    def __str__(self):
        return f"SIMULATION ENDED!"

class OrderPlacementEvent(FinanceEvent):
    """
    Base class for representing events corresponding to placement of an order in the simulation.

    Attributes:
        bookId (int | None): The ID of the orderbook on which the order was attempted to be placed.
        orderId (int | None): The ID assigned to the order by the simulator.
        clientOrderId (int | None): Optional agent-assigned identifier for the order.
        side (int): The side of the book on which the order was attempted to be placed (0=BID, 1=ASK).
        quantity (float): The size of the order in base currency.
        success (bool): Flag indicating if the order was successfully placed or not.
        message (str): The message associated with the failure in case of unsuccessful placement.
    """
    b : int | None = Field(alias="bookId", default=None)
    o : int | None = Field(alias="orderId")
    c : int | None = Field(alias="clientOrderId")
    s : int = Field(alias="side")
    q : float = Field(alias="quantity")
    u : bool = Field(alias="success")
    m : str = Field(alias="message")
    l : float = Field(alias="leverage", default=0.0)
    f : int = Field(alias="settleFlag", default=-2)
    
    @property
    def bookId(self) -> int | None:
        return self.b
    
    @property
    def orderId(self) -> int | None:
        return self.o
    
    @property
    def clientOrderId(self) -> int | None:
        return self.c
    
    @property
    def side(self) -> int:
        return self.s
    
    @property
    def quantity(self) -> float:
        return self.q
    
    @property
    def success(self) -> bool:
        return self.u
    
    @property
    def message(self) -> str:
        return self.m
    
    @property
    def leverage(self) -> str:
        return self.l
    
    @property
    def settleFlag(self) -> str:
        return self.f

class LimitOrderPlacementEvent(OrderPlacementEvent):
    """
    Represents the event generated on placement of a Limit Order in the simulation.

    Attributes:
        price (float): The price level at which the order was attempted to be placed.
    """
    p : float = Field(alias="price")
    
    @property
    def price(self) -> float:
        return self.p
            
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        if json['type'] == 'RESPONSE_DISTRIBUTED_PLACE_ORDER_LIMIT':
            return LimitOrderPlacementEvent.model_construct(
                type=abbreviate(json['type']), timestamp=json['timestamp'], agentId=json['payload']['agentId'],
                bookId=json['payload']['payload']['requestPayload']['bookId'],
                orderId=json['payload']['payload']['orderId'],clientOrderId=json['payload']['payload']['requestPayload']['clientOrderId'],
                side=json['payload']['payload']['requestPayload']['direction'],
                price=json['payload']['payload']['requestPayload']['price'],quantity=json['payload']['payload']['requestPayload']['volume'],
                leverage=json['payload']['payload']['requestPayload']['leverage'], settleFlag=LoanSettlementOption.from_string(json['payload']['payload']['requestPayload']['settleFlag']),
                success=True,message=''
            )
        elif json['type'] == 'ERROR_RESPONSE_DISTRIBUTED_PLACE_ORDER_LIMIT':
            return LimitOrderPlacementEvent.model_construct(
                type=abbreviate(json['type']), timestamp=json['timestamp'], agentId=json['payload']['agentId'],
                bookId=json['payload']['payload']['requestPayload']['bookId'],
                orderId=None,clientOrderId=json['payload']['payload']['requestPayload']['clientOrderId'],
                side=json['payload']['payload']['requestPayload']['direction'],
                price=json['payload']['payload']['requestPayload']['price'],quantity=json['payload']['payload']['requestPayload']['volume'],
                leverage=json['payload']['payload']['requestPayload']['leverage'], settleFlag=LoanSettlementOption.from_string(json['payload']['payload']['requestPayload']['settleFlag']),
                success=False,message=json['payload']['payload']['errorPayload']['message']
            )
        
    def __str__(self):
        return f"{'PLACED' if self.success else 'FAILED TO PLACE'} {'BUY ' if self.side == 0 else 'SELL'} LIMIT ORDER{' #'+str(self.orderId) if self.orderId else ''}{' ('+str(self.clientOrderId)+')' if self.clientOrderId else ''} FOR {f'{1+self.leverage}x' if self.leverage > 0 else ''}{self.quantity}@{self.price} AT {duration_from_timestamp(self.timestamp)} (T={self.timestamp}){' : ' + self.message if not self.success else ''}"
        
class MarketOrderPlacementEvent(OrderPlacementEvent):
    """
    Represents the event generated on placement of a Market Order in the simulation.

    Attributes:
        currency (OrderCurrency): Indicator for the currecy used to specify the market order quantity
    """            
    r : OrderCurrency = Field(alias="currency")
    
    @property
    def currency(self) -> OrderCurrency:
        return self.r

    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        if json['type'] == 'RESPONSE_DISTRIBUTED_PLACE_ORDER_MARKET':
            return MarketOrderPlacementEvent.model_construct(
                type=abbreviate(json['type']), timestamp=json['timestamp'], agentId=json['payload']['agentId'],
                bookId=json['payload']['payload']['requestPayload']['bookId'],
                orderId=json['payload']['payload']['orderId'],clientOrderId=json['payload']['payload']['requestPayload']['clientOrderId'],
                side=json['payload']['payload']['requestPayload']['direction'],
                currency=json['payload']['payload']['requestPayload']['currency'],quantity=json['payload']['payload']['requestPayload']['volume'],
                leverage=json['payload']['payload']['requestPayload']['leverage'], settleFlag=LoanSettlementOption.from_string(json['payload']['payload']['requestPayload']['settleFlag']),
                success=True,message=''
            )
        elif json['type'] == 'ERROR_RESPONSE_DISTRIBUTED_PLACE_ORDER_MARKET':
            return MarketOrderPlacementEvent.model_construct(
                type=abbreviate(json['type']), timestamp=json['timestamp'], agentId=json['payload']['agentId'],
                bookId=json['payload']['payload']['requestPayload']['bookId'],
                orderId=None,clientOrderId=json['payload']['payload']['requestPayload']['clientOrderId'],
                side=json['payload']['payload']['requestPayload']['direction'],
                currency=json['payload']['payload']['requestPayload']['currency'],quantity=json['payload']['payload']['requestPayload']['volume'],
                leverage=json['payload']['payload']['requestPayload']['leverage'], settleFlag=LoanSettlementOption.from_string(json['payload']['payload']['requestPayload']['settleFlag']),
                success=False,message=json['payload']['payload']['errorPayload']['message']
            )
        
    def __str__(self):
        return f"{'PLACED' if self.success else 'FAILED TO PLACE'} {'BUY ' if self.side == 0 else 'SELL'} MARKET ORDER{' #'+str(self.orderId) if self.orderId else ''}{' ('+str(self.clientOrderId)+')' if self.clientOrderId else ''} FOR {f'{1+self.leverage}x' if self.leverage > 0 else ''}{self.quantity}{'' if self.currency==OrderCurrency.BASE else ' QUOTE'} AT {duration_from_timestamp(self.timestamp)} (T={self.timestamp}){' : ' + self.message if not self.success else ''}"
        
class OrderCancellationEvent(BaseModel):
    """
    Represents cancellation of a single order.

    Attributes:
        timestamp (int): The timestamp at which cancellation was attempted.
        bookId (int): The ID of the orderbook on which the order was attempted to be cancelled.
        orderId (int): The ID of the order attempted to be cancelled.
        quantity (float | None): The quantity of the order to be cancelled, in base currency. If `None`, the entire remaining size is cancelled.
        success (bool): Flag indicating if the order was successfully cancelled or not.
        message (str): The message associated with failure in case of unsuccessful cancellation.
    """
    t : int = Field(alias="timestamp")
    b : int = Field(alias="bookId")
    o : int = Field(alias="orderId")
    q : float | None = Field(alias="quantity")
    u : bool = Field(alias="success")
    m : str = Field(alias="message")
    
    @property
    def timestamp(self) -> int:
        return self.t
    
    @property
    def bookId(self) -> int:
        return self.b
    
    @property
    def orderId(self) -> int:
        return self.o
    
    @property
    def quantity(self) -> float | None:
        return self.q
    
    @property
    def success(self) -> bool:
        return self.u
    
    @property
    def message(self) -> str:
        return self.m

    def __str__(self):
        return f"{'CANCELLED' if self.success else 'FAILED TO CANCEL'} ORDER #{self.orderId}{' FOR ' + str(self.quantity) if self.quantity else ''} AT {duration_from_timestamp(self.timestamp)} (T={self.timestamp}){' : ' + self.message if not self.success else ''}"
        
class OrderCancellationsEvent(FinanceEvent):
    """
    Represents the event generated on cancellation of a list of orders.

    Attributes:
        bookId (int | None): The ID of the orderbook on which the orders were attempted to be cancelled.
        cancellations (list[OrderCancellationEvent]): A list of individual order cancellation events.
    """
    b : int | None = Field(alias="bookId", default=None)
    c : list[OrderCancellationEvent] = Field(alias="cancellations", default=[])
    
    @property
    def bookId(self) -> int | None:
        return self.b
    
    @property
    def cancellations(self) -> list[OrderCancellationEvent]:
        return self.c
    
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        event = OrderCancellationsEvent(type=abbreviate(json['type']), timestamp=json['timestamp'], agentId=json['payload']['agentId'], bookId=json['payload']['payload']['requestPayload']['bookId'])
        if json['type'] == 'RESPONSE_DISTRIBUTED_CANCEL_ORDERS':
            for cancellation in json['payload']['payload']['requestPayload']['cancellations']:
                event.cancellations.append(
                    OrderCancellationEvent.model_construct( timestamp=event.timestamp,
                        bookId=event.bookId, orderId=cancellation['orderId'],quantity=cancellation['volume'],
                        success=True,message=''
                    )
                )
        elif json['type'] == 'ERROR_RESPONSE_DISTRIBUTED_CANCEL_ORDERS':
            for cancellation in json['payload']['payload']['requestPayload']['cancellations']:
                event.cancellations.append(
                    OrderCancellationEvent.model_construct( timestamp=event.timestamp,
                        bookId=event.bookId, orderId=cancellation['orderId'],quantity=cancellation['volume'],
                        success=False,message=f"Order Id does not exist!"
                    )
                )
        return event
    
    def __str__(self):
        return "\n".join([f"{c}" for c in self.cancellations])
    
class ClosePositionEvent(BaseModel):
    """
    Represents closing the leveraged position associated with a single order.

    Attributes:
        timestamp (int): The timestamp at which closing was attempted.
        bookId (int): The ID of the orderbook on which the position was attempted to be closed.
        orderId (int): The ID of the order associated with the position attempted to be closed.
        quantity (float | None): The quantity of the position to be closed, in base currency. If `None`, the entire remaining position was closed.
        success (bool): Flag indicating if the position was successfully closed.
        message (str): The message associated with failure in case of unsuccessful closure.
    """
    t : int = Field(alias="timestamp")
    b : int = Field(alias="bookId")
    o : int = Field(alias="orderId")
    q : float | None = Field(alias="quantity")
    u : bool = Field(alias="success")
    m : str = Field(alias="message")
    
    @property
    def timestamp(self) -> int:
        return self.t
    
    @property
    def bookId(self) -> int:
        return self.b
    
    @property
    def orderId(self) -> int:
        return self.o
    
    @property
    def quantity(self) -> float | None:
        return self.q
    
    @property
    def success(self) -> bool:
        return self.u
    
    @property
    def message(self) -> str:
        return self.m

    def __str__(self):
        return f"{'CLOSED' if self.success else 'FAILED TO CLOSE'} POSITION FOR ORDER #{self.orderId}{' FOR ' + str(self.quantity) if self.quantity else ''} AT {duration_from_timestamp(self.timestamp)} (T={self.timestamp}){' : ' + self.message if not self.success else ''}"
        
class ClosePositionsEvent(FinanceEvent):
    """
    Represents the event generated on closing positions for a list of orders.

    Attributes:
        bookId (int | None): The ID of the orderbook on which the positions were attempted to be closed.
        closes (list[ClosePositionEvent]): A list of individual order position closure events.
    """
    b : int | None = Field(alias="bookId", default=None)
    o : list[ClosePositionEvent] = Field(alias="closes", default=[])
    
    @property
    def bookId(self) -> int | None:
        return self.b
    
    @property
    def closes(self) -> list[ClosePositionEvent]:
        return self.o
    
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        event = ClosePositionsEvent.model_construct(type=abbreviate(json['type']), timestamp=json['timestamp'], agentId=json['payload']['agentId'], bookId=json['payload']['payload']['requestPayload']['bookId'])
        if json['type'] == 'RESPONSE_DISTRIBUTED_CLOSE_POSITIONS':
            for close in json['payload']['payload']['requestPayload']['closePositions']:
                event.closes.append(
                    ClosePositionEvent.model_construct( timestamp=event.timestamp,
                        bookId=event.bookId, orderId=close['orderId'],quantity=close['volume'],
                        success=True,message=''
                    )
                )
        elif json['type'] == 'ERROR_RESPONSE_DISTRIBUTED_CLOSE_POSITIONS':
            for close in json['payload']['payload']['requestPayload']['closePositions']:
                event.closes.append(
                    ClosePositionEvent.model_construct( timestamp=event.timestamp,
                        bookId=event.bookId, orderId=close['orderId'],quantity=close['volume'],
                        success=False,message=json['payload']['payload']['errorPayload']['message']
                    )
                )
        return event
    
    def __str__(self):
        return "\n".join([f"{c}" for c in self.closes])
    
class TradeEvent(FinanceEvent):
    """
    Represents the event generated on execution of trade in the simulation.

    Attributes:
        bookId (int | None): The ID of the orderbook on which the trade occurred.
        tradeId (int): The ID of the trade as assigned by the simulator.
        clientOrderId (int | None): Optional agent-assigned identifier for the resting order which was traded.
        takerAgentId (int): The ID of the agent which initiated the trade (aggressor).
        takerOrderId (int): The ID of the aggressing order involved in the trade.
        takerFee (float): The fee paid by the agent which placed the aggressing order.
        makerAgentId (int): The ID of the agent which placed the resting order involved in the trade.
        makerOrderId (int): The ID of the resting order involved in the trade.
        makerFee (float): The fee paid by the agent which placed the resting order.
        side (int): The direction of the trade; 0 if buy-initiated, otherwise 1.
        price (float): The price level at which the trade occurred.
        quantity (float): The quantity traded in base currency.
    """
    b : int | None = Field(alias="bookId", default=None)
    i : int = Field(alias="tradeId")
    c : int | None = Field(alias="clientOrderId", default=None)
    Ta : int = Field(alias="takerAgentId")
    Ti : int = Field(alias="takerOrderId")
    Tf : float = Field(alias="takerFee")
    Ma : int = Field(alias="makerAgentId")
    Mi : int = Field(alias="makerOrderId")
    Mf : float = Field(alias="makerFee")
    s : int = Field(alias="side")
    p : float = Field(alias="price")
    q : float = Field(alias="quantity")
    
    @property
    def bookId(self) -> int | None:
        return self.b
    
    @property
    def tradeId(self) -> int:
        return self.i
    
    @property
    def clientOrderId(self) -> int | None:
        return self.c
    
    @property
    def takerAgentId(self) ->int:
        return self.Ta
    
    @property
    def takerOrderId(self) ->int:
        return self.Ti
    
    @property
    def takerFee(self) ->float:
        return self.Tf
    
    @property
    def makerAgentId(self) ->int:
        return self.Ma
    
    @property
    def makerOrderId(self) ->int:
        return self.Mi
    
    @property
    def makerFee(self) ->float:
        return self.Mf
    
    @property
    def side(self) ->int:
        return self.s
    
    @property
    def price(self) ->float:
        return self.p
    
    @property
    def quantity(self) ->float:
        return self.q
    
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        return TradeEvent.model_construct(
            type=abbreviate(json['type']), timestamp=json['timestamp'], agentId=json['payload']['agentId'],
            bookId=json['payload']['payload']['bookId'], tradeId=json['payload']['payload']['trade']['tradeId'], 
            clientOrderId=json['payload']['payload']['clientOrderId'],
            takerAgentId=json['payload']['payload']['context']['aggressingAgentId'], takerOrderId=json['payload']['payload']['trade']['aggressingOrderId'],
            makerAgentId=json['payload']['payload']['context']['restingAgentId'], makerOrderId=json['payload']['payload']['trade']['restingOrderId'],
            side=json['payload']['payload']['trade']['direction'],price=json['payload']['payload']['trade']['price'],quantity=json['payload']['payload']['trade']['volume'],
            makerFee=json['payload']['payload']['context']['fees']['maker'], takerFee=json['payload']['payload']['context']['fees']['taker']
        )
    
    def __str__(self):
        return f"{'BUY ' if self.side == 0 else 'SELL'} TRADE #{self.tradeId} : AGGRESSIVE ORDER #{self.takerOrderId} (AGENT {self.takerAgentId}) MATCHED AGAINST #{self.makerOrderId} (AGENT {self.makerAgentId}) FOR {self.quantity}@{self.price} AT {duration_from_timestamp(self.timestamp)} (T={self.timestamp})"
    

class ResetAgentEvent(FinanceEvent):
    """
    Represents the event generated when a single agent account is reset (requested by validator on deregistration).

    Attributes:
        success (bool): Flag indicating if the agent's accounts were successfully reset.
        message (str): Message associated with failure if the reset was unsuccessful.
    """
    u : bool = Field(alias="success")
    m : str = Field(alias="message")
    
    @property
    def success(self) -> bool:
        return self.u
    
    @property
    def message(self) -> str:
        return self.m
    
    def __str__(self):
        return f"{'RESET' if self.success else 'FAILED TO RESET'} AGENT #{self.agentId} AT {duration_from_timestamp(self.timestamp)} (T={self.timestamp}){' : ' + self.message if not self.success else ''}"

class ResetAgentsEvent(FinanceEvent):
    """
    Represents the event generated on reset of a list of agents.

    Attributes:
        resets (list[ResetAgentEvent]): List of individual agent reset events.
    """
    r : list[ResetAgentEvent] =  Field(alias="resets", default=[])
    
    @property
    def resets(self) -> list[ResetAgentEvent]:
        return self.r
    
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        event = ResetAgentsEvent(type=abbreviate(json['type']), timestamp=json['timestamp'], agentId=json['payload']['agentId'])
        if json['type'] == 'RESPONSE_DISTRIBUTED_RESET_AGENT':
            for agentId in json['payload']['payload']['agentIds']:
                event.resets.append(
                    ResetAgentEvent.model_construct(
                        type=abbreviate(json['type']),
                        timestamp=json['timestamp'],
                        agentId=agentId,
                        success=True,
                        message=''
                    )
                )
        elif json['type'] == 'ERROR_RESPONSE_DISTRIBUTED_RESET_AGENT':
            for agentId in json['payload']['payload']['agentIds']:
                event.resets.append(
                    ResetAgentEvent.model_construct(
                        type=abbreviate(json['type']),
                        timestamp=json['timestamp'],
                        agentId=agentId,
                        success=False,
                        message=f"Proxy agent {event.agentId} failed to reset balance for agent {agentId} : Agent Id does not exist!"
                    )
                )
        return event 
    
    def __str__(self):
        return "\n".join([f"{r}" for r in self.resets])
    
                
from typing import Optional
from taos.im.protocol.models import EventHistory

class AgentEventHistory(EventHistory):
    """
    AgentEventHistory is a specialized history tracker for market events related
    to a single agent. It supports three types of events:

    - Trades (`TradeEvent`)
    - Orders (`MarketOrderPlacementEvent` or `LimitOrderPlacementEvent`)
    - Cancellations (`OrderCancellationEvent`)

    The history can be queried, appended with new events, and trimmed based on
    a configurable retention window.
    """

    events: dict[int, MarketOrderPlacementEvent | LimitOrderPlacementEvent | OrderCancellationEvent | TradeEvent]

    def __init__(
        self,
        uid:int,
        start: int,
        end: int,
        events: list[MarketOrderPlacementEvent | LimitOrderPlacementEvent | OrderCancellationEvent | TradeEvent],
        publish_interval: int,
        retention_mins: Optional[int] = None
    ):
        """
        Initializes the AgentEventHistory object.

        Args:
            start (int): Start timestamp in nanoseconds.
            end (int): End timestamp in nanoseconds.
            events (list): Initial set of agent-related events.
            publish_interval (int): Interval at which states are published.
            retention_mins (int | None): Optional retention window in minutes. If set,
                                         events older than this window are discarded.
        """
        self.uid = uid
        self.events = {e.timestamp: e for e in events}
        self.start = start
        self.end = end
        self.retention_mins = retention_mins
        self.publish_interval = publish_interval

    @property
    def trades(self) -> dict[int, TradeEvent]:
        """Return all trades indexed by timestamp."""
        return {ts: e for ts, e in self.events.items() if isinstance(e, TradeEvent)}

    @property
    def orders(self) -> dict[int, MarketOrderPlacementEvent | LimitOrderPlacementEvent]:
        """Return all order placements (limit or market) indexed by timestamp."""
        return {ts: e for ts, e in self.events.items() if isinstance(e, (LimitOrderPlacementEvent, MarketOrderPlacementEvent))}

    @property
    def cancellations(self) -> dict[int, OrderCancellationEvent]:
        """Return all order cancellations indexed by timestamp."""
        return {ts: e for ts, e in self.events.items() if isinstance(e, OrderCancellationEvent)}

    def append(self, state: 'MarketSimulationStateUpdate') -> 'AgentEventHistory':
        """
        Append new events from a MarketSimulationStateUpdate into this history.

        Events are stored keyed by timestamp. 
        Expired events are dropped if retention is enabled.

        Args:
            state (MarketSimulationStateUpdate): The state update containing notices.

        Returns:
            AgentEventHistory: Self, with updated events and time range.
        """
        new_events = [
            e for e in state.notices[self.uid]
            if e.type in {"RDPOL", "RDPOM", "RDCO", "ET"}
        ]

        for event in new_events:
            ts = event.timestamp
            self.events[ts] = event
            if self.start is None:
                self.start = ts
            else:
                self.start = min(self.start, ts)
            self.end = max(self.end, ts)

        # Apply retention logic once per batch
        if self.retention_mins is not None and self.events:
            retention_threshold = self.end - self.retention_mins * 60_000_000_000

            # Pop from the left until within threshold
            while self.events:
                first_ts = next(iter(self.events))
                if first_ts >= retention_threshold:
                    break
                self.events.pop(first_ts)

            # Update start based on remaining events
            self.start = next(iter(self.events), self.end)

        return self